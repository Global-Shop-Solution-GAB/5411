Program.Sub.Preflight.Start
Program.External.Include.Library("450100.lib")
Program.External.Include.Library("CustomLogging.lib")
Program.Sub.Preflight.End

Program.Sub.Main.Start
F.Intrinsic.Control.Try
V.Local.sError.Declare

'GCG_5411_Import.g2u
'Trey S
'1/25/2019
'For Vulcan Industries
'This script is for the Packsize interface, this will read a file generated by Packsize and issue material based off of it

V.Local.sSQL.Declare(String)
V.Local.sImportPath.Declare(String)
V.Local.sDefaultPart.Declare(String)
V.Local.sSelect.Declare(String)
V.Local.sDataTableRT.Declare(String)
V.Local.sRet.Declare(String)
V.Local.bExists.Declare(Boolean)
V.Local.sFileFilter.Declare(String)
V.Local.sFileList.Declare(String)
V.Local.bInString.Declare(Boolean)
V.Local.iCounter.Declare(Long)
V.Local.iJ.Declare(Long)
V.Local.sCurrentData.Declare(String)
V.Local.sCurrentFile.Declare(String)
V.Local.sColumns.Declare(String)
V.Local.sTypes.Declare(String)
V.Local.iStart.Declare(Long)
V.Local.sProcessedFile.Declare(String)
V.Local.iFileReturn.Declare(Long)
V.Local.sPart.Declare(String)
V.Local.sWO.Declare(String)
V.Local.sSuffix.Declare(String)
V.Local.sSequence.Declare(String)
V.Local.sFilter.Declare(String)
V.Local.sFile.Declare(String)
V.Local.sFullFileList.Declare(String)
V.Local.sNewName.Declare(String)
V.Local.sJob.Declare(String)
V.Local.sMessage.Declare(String)
V.Local.sValid.Declare(String)
V.Local.sValidFile.Declare(String)
V.Local.sBin.Declare(String)

F.ODBC.Connection!Con.OpenCompanyConnection

'get settings, validate
F.Data.DataTable.CreateFromSQL("dtSettings", "Con", "select RTRIM(SETTING) as SETTING, RTRIM(VALUE) as VALUE from GCG_5411_Maintenance where SETTING = 'IMP' or SETTING = 'BIN'")

F.Data.DataTable.Select("dtSettings", "SETTING = 'IMP'", V.Local.sDataTableRT)
F.Intrinsic.Control.If(V.Local.sDataTableRT.IsNotNoReturn)
	V.Local.sImportPath.Set(V.DataTable.dtSettings(V.Local.sDataTableRT).VALUE!FieldValTrim)
F.Intrinsic.Control.Else
	F.Intrinsic.Control.CallSub(LOGGINGAddLog, "Project", "5411", "Message", "PackSize Import Error: No valid import path set up in Packsize Interface Maintenance.")
	F.Intrinsic.UI.InvokeWaitDialog("No valid import path set up in Packsize Interface Maintenance.", "PackSize Import Error")
	F.Intrinsic.UI.Sleep(10)
	F.ODBC.Connection!Con.Close
	F.Intrinsic.Control.End
F.Intrinsic.Control.EndIf

F.Data.DataTable.Select("dtSettings", "SETTING = 'BIN'", V.Local.sDataTableRT)
F.Intrinsic.Control.If(V.Local.sDataTableRT.IsNotNoReturn)
	V.Local.sBin.Set(V.DataTable.dtSettings(V.Local.sDataTableRT).VALUE!FieldValTrim)
F.Intrinsic.Control.Else
	F.Intrinsic.Control.CallSub(LOGGINGAddLog, "Project", "5411", "Message", "No valid default bin set up in Packsize Interface Maintenance.")
	F.Intrinsic.UI.InvokeWaitDialog("No valid default bin set up in Packsize Interface Maintenance.", "PackSize Import Error")
	F.Intrinsic.UI.Sleep(10)
	F.ODBC.Connection!Con.Close
	F.Intrinsic.Control.End
F.Intrinsic.Control.EndIf

F.Data.DataTable.Close("dtSettings")
F.Intrinsic.Control.CallSub(CheckDir, "Path", V.Local.sImportPath)

F.Intrinsic.String.Build("{0}\*.csv", V.Local.sImportPath, V.Local.sFileFilter)
F.Intrinsic.File.GetFileList(V.Local.sFileFilter, V.Local.sFileList)

'close if no files to process
F.Intrinsic.Control.If(V.Local.sFileList.Trim, =, "")
	F.ODBC.Connection!Con.Close
	F.Intrinsic.Control.End
F.Intrinsic.Control.EndIf

V.Local.sColumns.Set("WO*!*PACKSIZE_Part*!*Qty")
V.Local.sTypes.Set("String*!*String*!*String")

'loop through each file
V.Local.sFullFileList.Set(V.Local.sFileList)
F.Intrinsic.String.Split(V.Local.sFileList, ":", V.Local.sFileList)
F.Intrinsic.Control.For(V.Local.iCounter, 0, V.Local.sFileList.UBound, 1)
	F.Intrinsic.String.Build("{0}\{1}", V.Local.sImportPath, V.Local.sFileList(V.Local.iCounter), V.Local.sCurrentFile)
	
	F.Intrinsic.String.Build("Processing file {0}", V.Local.sCurrentFile, V.Local.sMessage)
	F.Intrinsic.Control.CallSub(LOGGINGAddLog, "Project", "5411", "Message", V.Local.sMessage)
	
	F.Intrinsic.File.File2String(V.Local.sCurrentFile, V.Local.sCurrentData)
	F.Data.DataTable.CreateFromString("dtIssue", V.Local.sCurrentData, V.Local.sColumns, V.Local.sTypes, ",", V.Ambient.NewLine)
	
	F.Data.DataTable.AddExpressionColumn("dtIssue", "WorkOrder", "String", "SUBSTRING([WO], 1, 6)")
	F.Data.DataTable.AddExpressionColumn("dtIssue", "Suffix", "String", "SUBSTRING([WO], 8, 3)")
	F.Data.DataTable.AddColumn("dtIssue", "Location", "String", "")
	F.Data.DataTable.AddColumn("dtIssue", "Bin", "String", V.Local.sBin)
	
	F.Data.DataView.Create("dtIssue", "dvIssue", 22, "WO <> 'WorkOrderNumber' and [WO] <> ''", "")
	F.Intrinsic.Control.If(V.DataView.dtIssue!dvIssue.RowCount, !=, 0)
		
		'get the WO info we need to issue material
		V.Local.sSQL.Set("select RTRIM(JOB) as WONumber, RTRIM(SUFFIX) as WOSuffix, RTRIM(SEQ) as WOSeq, HOURS_ESTIMATED, HOURS_ACTUAL, FLAG_CLOSED from V_JOB_OPERATIONS where LMO = 'M' and PART = '9010999'")
		F.Data.DataTable.CreateFromSQL("dtWOs", "Con", V.Local.sSQL)
		F.Data.Linq.Join("LeftJoin", "DataView", "dtIssue", "dvIssue*!*A", "DataTable", "dtWOs*!*B", "A.WorkOrder = B.WONumber and A.Suffix = B.WOSuffix", "B.WONumber*!*B.WOSuffix*!*B.WOSeq*!*B.HOURS_ESTIMATED*!*B.HOURS_ACTUAL*!*B.FLAG_CLOSED*!*A.Qty*!*A.WO*!*A.PACKSIZE_Part*!*A.LOCATION*!*A.Bin", "", "", "", "dtFinal", True)
		F.Data.DataTable.Close("dtWOs")
		
		F.Intrinsic.Control.If(V.DataTable.dtFinal.Exists)
			'formatting
			F.Data.DataTable.AddExpressionColumn("dtFinal", "QtyDouble", "Float", "CONVERT(Qty, 'System.Double')")
			F.Data.DataTable.AddExpressionColumn("dtFinal", "Issued", "Float", "[HOURS_ACTUAL] + [QtyDouble]")
			F.Data.DataTable.AddColumn("dtFinal", "Quantity", "String")
			F.Data.DataTable.SetValueFormat("dtFinal", -1, "QtyDouble", "Quantity", "##########0.0000")
			
			F.Data.DataTable.AddColumn("dtFinal", "PART", "String")
			F.Data.Dictionary.CreateFromSQL("dictParts", "Con", "select RTRIM(PART) as PART, RTRIM(PART) as PART from V_INVENTORY_MSTR")
			F.Data.Dictionary.SetDefaultReturn("dictParts", "")
			F.Data.DataTable.FillFromDictionary("dtFinal", "dictParts", "PACKSIZE_PART", "PART")
			F.Data.Dictionary.Close("dictParts")
			
			F.Data.DataView.Create("dtFinal", "dvFinal", 22, "[WONumber] <> '' and [PART] <> ''", "")
			F.Intrinsic.Control.If(V.DataView.dtFinal!dvFinal.RowCount, =, 0)
				F.Intrinsic.Control.CallSub(LOGGINGAddLog, "Project", "5411", "Message", "No usable records, moving to Failed directory. Check that the Work Orders, Parts, and Quantities are valid, and that the work order has a material sequence with the part number 9010999")
				V.Local.sNewName.Set(V.Local.sFileList(V.Local.iCounter))
				F.Intrinsic.String.Build("{0}\{1}", V.Local.sImportPath, V.Local.sFileList(V.Local.iCounter), V.Local.sCurrentFile)
				F.Intrinsic.String.Build("{0}\Failed\{1}", V.Local.sImportPath, V.Local.sNewName, V.Local.sProcessedFile)
				F.Intrinsic.File.MoveFile(V.Local.sCurrentFile, V.Local.sProcessedFile, V.Local.iFileReturn)
				
			F.Intrinsic.Control.Else
				'issue
				F.Data.DataView.ToDataTable("dtFinal", "dvFinal", "dt450100")
				F.Data.DataTable.Merge("dt450100", "450100", True, 2)
				F.Intrinsic.Control.CallSub(450100Sync)
				F.Data.DataTable.AcceptChanges("450100")
				
				'close the ones where the issued exceeds the estimated
				F.Data.DataView.Create("dt450100", "dvClose", 22, "[ISSUED] >= [HOURS_ESTIMATED]", "")
				F.Data.DataView.ToDataTable("dt450100", "dvClose", "dtClose")
				F.Data.DataView.Close("dt450100", "dvClose")
				F.Intrinsic.Control.If(V.DataTable.dtClose.RowCount, >, 0)
					F.Data.DataTable.AddColumn("dtClose", "DATE_COMPLETED", "String", V.Ambient.Date.FormatYYMMDD)
					F.Data.DataTable.SetValue("dtClose", -1, "FLAG_CLOSED", "Y")
					F.Data.DataTable.SaveToDB("dtClose", "Con", "JOB_OPERATIONS", "WONumber*!*WOSuffix*!*WOSeq", 256, "WONumber@!@Job*!*WOSuffix@!@Suffix*!*WOSeq@!@SEQ*!*FLAG_CLOSED@!@FLAG_CLOSED*!*DATE_COMPLETED@!@DATE_COMPLETED")
				F.Intrinsic.Control.EndIf
				F.Data.DataTable.Close("dtClose")
				F.Data.DataTable.Close("dt450100")
				
				'move to processed
				F.Intrinsic.String.Replace(V.Local.sFileList(V.Local.iCounter), ".csv", "", V.Local.sNewName)
				F.Intrinsic.String.Build("{0}_{1}{2}.csv", V.Local.sNewName, V.Ambient.Date.FormatYYYYMMDD, V.Ambient.Time.FormatHHNNSS, V.Local.sNewName)
				F.Intrinsic.File.MakeFilenameFriendly(V.Local.sNewName, V.Local.sNewName)
				F.Intrinsic.String.Build("{0}\{1}", V.Local.sImportPath, V.Local.sFileList(V.Local.iCounter), V.Local.sCurrentFile)
				F.Intrinsic.String.Build("{0}\Processed\{1}", V.Local.sImportPath, V.Local.sNewName, V.Local.sProcessedFile)
				F.Intrinsic.File.MoveFile(V.Local.sCurrentFile, V.Local.sProcessedFile, V.Local.iFileReturn)
				
				'F.Data.DataView.ToString("dtFinal", "dvFinal", "WONumber*!*WOSuffix*!*PART*!*Qty", ",", V.Ambient.NewLine, V.Local.sValid)
				F.Data.DataView.ToString("dtFinal", "dvFinal", "WO*!*PART*!*Qty", ",", V.Ambient.NewLine, V.Local.sValid)
				F.Intrinsic.String.Replace(V.Local.sFileList(V.Local.iCounter), ".csv", "", V.Local.sNewName)
				F.Intrinsic.String.Build("{0}_VALID.csv", V.Local.sNewName, V.Local.sNewName)
				F.Intrinsic.File.MakeFilenameFriendly(V.Local.sNewName, V.Local.sNewName)
				F.Intrinsic.String.Build("{0}\Processed\{1}", V.Local.sImportPath, V.Local.sNewName, V.Local.sValidFile)
				F.Intrinsic.File.String2File(V.Local.sValidFile, V.Local.sValid)
			F.Intrinsic.Control.EndIf
			
		F.Intrinsic.Control.Else
			F.Intrinsic.Control.CallSub(LOGGINGAddLog, "Project", "5411", "Message", "File is empty, moving to Failed directory.")
			
			'move to failed if no usable records
			V.Local.sNewName.Set(V.Local.sFileList(V.Local.iCounter))
			F.Intrinsic.String.Build("{0}\{1}", V.Local.sImportPath, V.Local.sFileList(V.Local.iCounter), V.Local.sCurrentFile)
			F.Intrinsic.String.Build("{0}\Failed\{1}", V.Local.sImportPath, V.Local.sNewName, V.Local.sProcessedFile)
			F.Intrinsic.File.MoveFile(V.Local.sCurrentFile, V.Local.sProcessedFile, V.Local.iFileReturn)
		F.Intrinsic.Control.EndIf
		
		F.Data.DataView.Close("dtIssue", "dvIssue")
		F.Data.DataTable.Close("dtIssue")
		F.Data.DataView.Close("dtFinal", "dvFinal")
		F.Data.DataTable.Close("dtFinal")
	F.Intrinsic.Control.Else
			F.Intrinsic.Control.CallSub(LOGGINGAddLog, "Project", "5411", "Message", "File is empty, moving to Failed directory.")
			
			'move to failed if no usable records
			V.Local.sNewName.Set(V.Local.sFileList(V.Local.iCounter))
			F.Intrinsic.String.Build("{0}\{1}", V.Local.sImportPath, V.Local.sFileList(V.Local.iCounter), V.Local.sCurrentFile)
			F.Intrinsic.String.Build("{0}\Failed\{1}", V.Local.sImportPath, V.Local.sNewName, V.Local.sProcessedFile)
			F.Intrinsic.File.MoveFile(V.Local.sCurrentFile, V.Local.sProcessedFile, V.Local.iFileReturn)
	F.Intrinsic.Control.EndIf
		
F.Intrinsic.Control.Next(V.Local.iCounter)

F.ODBC.Connection!Con.Close

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.If(V.Ambient.ErrorNumber, =, 213)
		F.Intrinsic.File.DeleteFile(V.Local.sCurrentFile)
	F.Intrinsic.Control.EndIf
	F.Intrinsic.String.Build("Project: {0}{1}{1}Subroutine: {2}{1}Error Occurred {3} with description {4}{1}{1}GAB Version: {5}",V.Ambient.ScriptPath,V.Ambient.Newline,V.Ambient.CurrentSubroutine,V.Ambient.ErrorNumber,V.Ambient.ErrorDescription,V.Ambient.GABVersion,V.Local.sError)
	F.Intrinsic.Control.CallSub(LOGGINGAddLog, "Project", "5411", "Message", V.Local.sError)
	F.Intrinsic.Control.CallSub(LOGGINGAddLog, "Project", "5411", "Message", "Moving all current files to Failed directory.")
	'F.Intrinsic.UI.Msgbox(V.Local.sError)
	F.Intrinsic.Control.CallSub(AllFail, "FileList", V.Local.sFullFileList, "ImportPath", V.Local.sImportPath)
	F.Intrinsic.Control.End 
F.Intrinsic.Control.EndTry
Program.Sub.Main.End

Program.Sub.CheckDir.Start
F.Intrinsic.Control.Try
V.Local.sError.Declare

'check if the given import directories exist
'create them if they don't
V.Local.sPath.Declare(String)
V.Local.bExists.Declare(Boolean)
V.Local.sProcessedPath.Declare(String)
V.Local.sFailedPath.Declare(String)

V.Local.sPath.Set(V.Args.Path)
F.Intrinsic.File.DirExists(V.Local.sPath, V.Local.bExists)
F.Intrinsic.Control.If(V.Local.bExists.Not)
	F.Intrinsic.File.CreateDir(V.Local.sPath)
F.Intrinsic.Control.EndIf

F.Intrinsic.String.Build("{0}\Processed", V.Local.sPath, V.Local.sProcessedPath)
F.Intrinsic.File.DirExists(V.Local.sProcessedPath, V.Local.bExists)
F.Intrinsic.Control.If(V.Local.bExists.Not)
	F.Intrinsic.File.CreateDir(V.Local.sProcessedPath)
F.Intrinsic.Control.EndIf

F.Intrinsic.String.Build("{0}\Failed", V.Local.sPath, V.Local.sFailedPath)
F.Intrinsic.File.DirExists(V.Local.sFailedPath, V.Local.bExists)
F.Intrinsic.Control.If(V.Local.bExists.Not)
	F.Intrinsic.File.CreateDir(V.Local.sFailedPath)
F.Intrinsic.Control.EndIf

F.Intrinsic.Control.Catch
	F.Intrinsic.String.Build("Project: {0}{1}{1}Subroutine: {2}{1}Error Occurred {3} with description {4}{1}{1}GAB Version: {5}",V.Ambient.ScriptPath,V.Ambient.Newline,V.Ambient.CurrentSubroutine,V.Ambient.ErrorNumber,V.Ambient.ErrorDescription,V.Ambient.GABVersion,V.Local.sError)
	F.Intrinsic.Control.CallSub(LOGGINGAddLog, "Project", "5411", "Message", V.Local.sError)
	F.Intrinsic.Control.CallSub(LOGGINGAddLog, "Project", "5411", "Message", "Moving all current files to Failed directory.")
	F.Intrinsic.UI.Msgbox(V.Local.sError)
	F.Intrinsic.Control.End 
F.Intrinsic.Control.EndTry
Program.Sub.CheckDir.End

Program.Sub.AllFail.Start
F.Intrinsic.Control.Try
V.Local.sError.Declare

'the program crashed, move all unprocessed files to fail directory
V.Local.sFileList.Declare(String)
V.Local.iCounter.Declare(Long)
V.Local.bExists.Declare(Boolean)
V.Local.sImportPath.Declare(String)
V.Local.sFile.Declare(String)
V.Local.sFailedFile.Declare(String)
V.Local.iRet.Declare(Long)
V.Local.sNewName.Declare(String)
V.Local.sCurrentFile.Declare(String)

V.Local.sImportPath.Set(V.Args.ImportPath)
V.Local.sFileList.Set(V.Args.FileList)

F.Intrinsic.Control.If(V.Local.sFileList.Trim, =, "")
	F.Intrinsic.Control.End
F.Intrinsic.Control.EndIf

F.Intrinsic.String.Split(V.Local.sFileList, ":", V.Local.sFileList)
F.Intrinsic.Control.For(V.Local.iCounter, 0, V.Local.sFileList.UBound, 1)
	F.Intrinsic.String.Build("{0}\{1}", V.Local.sImportPath, V.Local.sFileList(V.Local.iCounter), V.Local.sFile)
	F.Intrinsic.File.Exists(V.Local.sFile, V.Local.bExists)
	F.Intrinsic.Control.If(V.Local.bExists)
			V.Local.sNewName.Set(V.Local.sFileList(V.Local.iCounter))
		F.Intrinsic.String.Build("{0}\Failed\{1}", V.Local.sImportPath, V.Local.sNewName, V.Local.sFailedFile)
		F.Intrinsic.File.MoveFile(V.Local.sFile, V.Local.sFailedFile, V.Local.iRet)
	F.Intrinsic.Control.EndIf
F.Intrinsic.Control.Next(V.Local.iCounter)

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.If(V.Ambient.ErrorNumber, =, 213)
		F.Intrinsic.File.DeleteFile(V.Local.sFile)
	F.Intrinsic.Control.EndIf
	F.Intrinsic.String.Build("Project: {0}{1}{1}Subroutine: {2}{1}Error Occurred {3} with description {4}{1}{1}GAB Version: {5}",V.Ambient.ScriptPath,V.Ambient.Newline,V.Ambient.CurrentSubroutine,V.Ambient.ErrorNumber,V.Ambient.ErrorDescription,V.Ambient.GABVersion,V.Local.sError)
	F.Intrinsic.Control.CallSub(LOGGINGAddLog, "Project", "5411", "Message", V.Local.sError)
	F.Intrinsic.Control.CallSub(LOGGINGAddLog, "Project", "5411", "Message", "Moving all current files to Failed directory.")
	F.Intrinsic.Control.End 
F.Intrinsic.Control.EndTry
Program.Sub.AllFail.End